RWTexture2D<float4> gSceneColor;
RWTexture2D<float4> gFilterResult;


#define KERNEL_SIZE 3
SCREEN_PASS_TEXTURE_VIEWPORT(InputInfo)


// cbuffer CB
// {
//     uint2 texDim;
// };
bool outside(int2 pixelPos, uint2 dim){
	BRANCH
    if (pixelPos.x < 0 || pixelPos.y < 0){
        return true;
    }

	BRANCH
    if (pixelPos.x >= dim.x || pixelPos.y >= dim.y){
        return true;
    }

    return false;
}

[numthreads(16, 16, 1)]
void MyMain(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex)
{
	int2 PixelPos = DispatchThreadId.xy;
	// float2 UV = ((float2)PixelPos.xy + 0.5) * VelocityTile_ExtentInverse;

    int2 texDim = InputInfo_ViewportMax;

    uint count = 0;
    gFilterResult[PixelPos] = float4(0.0, 0.0, 0.0, 1.0);
    for (int i = -1; i <= KERNEL_SIZE/2; i++){
        for (int j = -1; j <= KERNEL_SIZE/2; j++){
            int2 newPixelPos = PixelPos + int2(i, j);
    
	        BRANCH
            if (!outside(newPixelPos,texDim)){
                count += 1;
                gFilterResult[PixelPos].xyz += gSceneColor[newPixelPos].xyz;

            }
        }
    }
    gFilterResult[PixelPos].xyz /= float(count);

}

/*


[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void VelocityFlattenMain(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex) 
{ 
	uint2 PixelPos = min(DispatchThreadId.xy + Velocity_ViewportMin, Velocity_ViewportMax - 1);

	float2 Velocity = VelocityTexture[PixelPos].xy;
	float Depth = DepthTexture[PixelPos].x;

	if (Velocity.x > 0.0)
	{
		Velocity = DecodeVelocityFromTexture(Velocity);
	}
	else
	{
		// Compute velocity due to camera motion.
		float2 ViewportUV = ((float2)DispatchThreadId.xy + 0.5) / Velocity_ViewportSize;
		float2 ScreenPos = 2 * float2(ViewportUV.x, 1 - ViewportUV.y) - 1;
		float4 ThisClip = float4(ScreenPos, Depth, 1);
		float4 PrevClip = mul(ThisClip, View.ClipToPrevClip);
		float2 PrevScreen = PrevClip.xy / PrevClip.w;
		Velocity = ScreenPos - PrevScreen;
	}

	Velocity.y *= -MotionBlur_AspectRatio;

	float2 VelocityPolar = CartesianToPolar(Velocity);

	// If the velocity vector was zero length, VelocityPolar will contain NaNs.
	if (any(isnan(VelocityPolar)))
	{
		VelocityPolar = float2(0.0f, 0.0f);
	}

	bool bInsideViewport = all(PixelPos.xy < Velocity_ViewportMax);

	// 11:11:10  (VelocityLength, VelocityAngle, Depth)
	float2 EncodedVelocity;
	EncodedVelocity.x = VelocityPolar.x;
	EncodedVelocity.y = VelocityPolar.y * (0.5 / PI) + 0.5;

	BRANCH
	if (bInsideViewport)
	{
		OutVelocityFlatTexture[PixelPos] = float3(EncodedVelocity, ConvertFromDeviceZ(Depth)).xyzz;
	}

	// Limit velocity
	VelocityPolar.x = min(VelocityPolar.x, MotionBlur_VelocityMax / MotionBlur_VelocityScale);

	float4 VelocityMinMax = VelocityPolar.xyxy;
	VelocityMinMax.x = bInsideViewport ? VelocityMinMax.x : 2;
	VelocityMinMax.z = bInsideViewport ? VelocityMinMax.z : 0;

	Shared[GroupIndex] = VelocityMinMax;

	GroupMemoryBarrierWithGroupSync();

#if THREADGROUP_TOTALSIZE > 512
	if (GroupIndex < 512) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 512]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 256
	if (GroupIndex < 256) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 256]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 128
	if (GroupIndex < 128) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 128]);
	GroupMemoryBarrierWithGroupSync();
#endif
#if THREADGROUP_TOTALSIZE > 64
	if (GroupIndex <  64) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  64]);
	GroupMemoryBarrierWithGroupSync();
#endif

	// Safe for vector sizes 32 or larger, AMD and NV
	// TODO Intel variable size vector
	if (GroupIndex < 32) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 32]);
	if (GroupIndex < 16) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex + 16]);
	if (GroupIndex <  8) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  8]);
	if (GroupIndex <  4) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  4]);
	if (GroupIndex <  2) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  2]);
	if (GroupIndex <  1) Shared[GroupIndex] = MinMaxLengthPolar(Shared[GroupIndex], Shared[GroupIndex +  1]);

	if (GroupIndex == 0)
	{
		OutVelocityTileTexture[GroupId.xy] = float4(PolarToCartesian(Shared[0].xy), PolarToCartesian(Shared[0].zw));
	}
}

*/